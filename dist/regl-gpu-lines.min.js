!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e="undefined"!=typeof globalThis?globalThis:e||self).reglLines=n()}(this,(function(){"use strict";var e={CAP_START:0,CAP_END:1,CAP_SHORT:2};const n=e;var t=function(e,t,r,o,i,s,a,f,p,c,l,d){const u=t?f:a,m=["B","C","D"];t||m.unshift("A");const v={},h={},g=p.concat(u.attrs);if(o){h.vao=e.prop("vao");for(let e=0;e<g.length;e++)v[g[e].name]=e}else for(const e of g)v[e.name]=e.spec;const y=r?t?e=>[e.capRes2,Math.max(e.capRes2,e.joinRes2)]:e=>[Math.max(e.capRes2,e.joinRes2),Math.max(e.capRes2,e.joinRes2)]:t?e=>[e.capRes2,e.joinRes2]:e=>[e.joinRes2,e.joinRes2];return e({vert:`${i.glsl}const float CAP_START=${n.CAP_START}.0;const float CAP_END=${n.CAP_END}.0;${u.glsl}attribute float index;${d?"attribute float debugInstanceID;":""}uniform bool _isRound;uniform vec2 _vertCnt2,_capJoinRes2;uniform vec2 _resolution,_capScale;uniform float _miterLimit;${i.orientation||!t?"":"uniform float _orientation;"}varying vec3 lineCoord;${d?"varying vec2 triStripCoord;":""}${d?"varying float instanceID;":""}${d?"varying float vertexIndex;":""}bool isnan(float val){return(val<0.0||0.0<val||val==0.0)?false:true;}bool invalid(vec4 p){return p.w==0.0||isnan(p.x);}void main(){const float pi=3.141592653589793;${d?"vertexIndex=index;":""}lineCoord=vec3(0);${d?`instanceID=${t?"-1.0":"debugInstanceID"};`:""}${d?"triStripCoord=vec2(floor(index/2.0),mod(index,2.0));":""}${m.map((e=>`vec4 p${e}=${i.position.generate(i,e)};`)).join("\n")}gl_Position=pB;bool aInvalid=${t?"false":"invalid(pA)"};bool bInvalid=invalid(pB);bool cInvalid=invalid(pC);bool dInvalid=invalid(pD);vec2 v=_vertCnt2+3.0;float N=dot(v,vec2(1));bool mirror=index>=v.x;${t?"if(dInvalid && mirror)return;":""}float pw=mirror?pC.w:pB.w;${m.map((e=>`p${e}=vec4(vec3(p${e}.xy*_resolution,p${e}.z)/p${e}.w,1);`)).join("\n")}${t?"vec4 pA=pC;":""}if(bInvalid||cInvalid||max(abs(pB.z),abs(pC.z))>1.0)return;if(mirror){vec4 vTmp=pC; pC=pB; pB=vTmp;vTmp=pD; pD=pA; pA=vTmp;bool bTmp=dInvalid; dInvalid=aInvalid; aInvalid=bTmp;}${t?"bool isCap=!mirror;":(r?"":"const ")+"bool isCap=false"};if(aInvalid){ ${r?"pA=pC; isCap=true;":"pA=2.0*pB-pC;"} }if(dInvalid){ ${r?"pD=pB;":"pD=2.0*pC-pB;"} }bool roundOrCap=_isRound||isCap;float width=mirror?${i.width.generate(i,"C")}:${i.width.generate(i,"B")};vec2 tBC=pC.xy-pB.xy;float lBC=length(tBC);tBC/=lBC;vec2 nBC=vec2(-tBC.y,tBC.x);vec2 tAB=pB.xy-pA.xy;float lAB=length(tAB);if(lAB>0.0)tAB/=lAB;vec2 nAB=vec2(-tAB.y,tAB.x);vec2 tCD=pD.xy-pC.xy;float lCD=length(tCD);if(lCD>0.0)tCD/=lCD;vec2 nCD=vec2(-tCD.y,tCD.x);float cosB=clamp(dot(tAB,tBC),-1.0,1.0);const float tol=1e-4;float mirrorSign=mirror?-1.0:1.0;float dirB=-dot(tBC,nAB);float dirC=dot(tBC,nCD);bool bCollinear=abs(dirB)<tol;bool cCollinear=abs(dirC)<tol;bool bIsHairpin=bCollinear && cosB<0.0;dirB=bCollinear?-mirrorSign:sign(dirB);dirC=cCollinear?-mirrorSign:sign(dirC);vec2 miter=bIsHairpin?-tBC:0.5*(nAB+nBC)*dirB;float i=mirror?N-index:index;float res=(isCap?_capJoinRes2.x:_capJoinRes2.y);i-=max(0.0,(mirror?_vertCnt2.y:_vertCnt2.x)-res);i+=(dirB<0.0?-1.0:0.0);i-=mirror?1.0:0.0;i=max(0.0,i);vec2 xBasis=tBC;vec2 yBasis=nBC*dirB;vec2 xy=vec2(0);lineCoord.y=dirB*mirrorSign;if(i==res+1.0){float m=cosB>-0.9999?(tAB.x*tBC.y-tAB.y*tBC.x)/(1.0+cosB):0.0;xy=vec2(min(abs(m),min(lBC,lAB)/width),-1);lineCoord.y=-lineCoord.y;} else {float m2=dot(miter,miter);float lm=sqrt(m2);yBasis=miter/lm;xBasis=dirB*vec2(yBasis.y,-yBasis.x);bool isBevel=1.0>_miterLimit*m2;if(mod(i,2.0)==0.0){if(roundOrCap||i !=0.0){float theta=-0.5*(acos(cosB)*(clamp(i,0.0,res)/res)-pi)*(isCap?2.0:1.0);xy=vec2(cos(theta),sin(theta));if(isCap){if(xy.y>0.001)xy*=_capScale;lineCoord.xy=xy.yx*lineCoord.y;}} else {yBasis=bIsHairpin?vec2(0):miter;xy.y=isBevel?1.0:1.0/m2;}} else {lineCoord.y=0.0;if(isBevel && !roundOrCap){xy.y=-1.0+sqrt((1.0+cosB)*0.5);}}}${t?`float _orientation=${i.orientation?i.orientation.generate(i,""):"mod(_orientation,2.0)"};`:""};${t?"if(_orientation==CAP_END)lineCoord.xy=-lineCoord.xy;":""}vec2 dP=mat2(xBasis,yBasis)*xy;float dx=dot(dP,tBC)*mirrorSign;float useC=(mirror?1.0:0.0)+dx*(width/lBC);lineCoord.z=useC<0.0||useC>1.0?1.0:0.0;${[...i.varyings.values()].map((e=>e.generate(i,"useC","B","C"))).join("\n")}gl_Position=pB;gl_Position.xy+=width*dP;gl_Position.xy/=_resolution;gl_Position*=pw;${i.postproject?`gl_Position=${i.postproject}(gl_Position);`:""}}`,frag:s,attributes:v,uniforms:{...l,_vertCnt2:(e,n)=>y(n),_capJoinRes2:(e,n)=>[n.capRes2,n.joinRes2],_miterLimit:(e,n)=>n.miterLimit*n.miterLimit,_orientation:e.prop("orientation"),_capScale:e.prop("capScale"),_isRound:(e,n)=>"round"===n.join,_resolution:(e,n)=>n.viewportSize||[e.viewportWidth,e.viewportHeight]},primitive:"triangle strip",instances:t?(e,t)=>t.instances*(t.splitCaps?t.orientation===n.CAP_START?Math.ceil(t.count/2):Math.floor(t.count/2):t.count):(e,n)=>n.instances*(n.count-3),count:(e,n)=>{const t=y(n);return 6+(t[0]+t[1])},...c,...h})};var r={NONE:0,REGULAR:1,EXTENDED:2,PER_INSTANCE:4};const o=r;var i=function(e){const n=[],t=e.split("\n");for(let e=0;e<t.length;e++)t[e]=t[e].replace(s,(function(e,t){return n.push(d(t)),""}));return{glsl:t.join("\n").trim(),...u(n)}};const s=/^\s*#pragma\s+lines\s*:\s*([^;]*);?$/i,a=/^\s*(?:(instance)?)\s*attribute\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*$/i,f=/^\s*(position|width|orientation)\s+=\s+([\w\d_]+)\s*\(([^)]*)\)\s*$/i,p=/^\s*(?:(extrapolate)?)\s*varying\s+(float|vec2|vec3|vec4)\s+([\w\d_]+)\s*=\s*([\w\d_]+)\(([^)]*)\)\s*$/,c=/^\s*postproject\s+=\s+([\w\d_]+)\s*$/i,l={float:1,vec2:2,vec3:3,vec4:4};function d(e){let n;if(n=(e=e.trim()).match(a)){const e=!!n[1];return{type:"attribute",dimension:l[n[2]],name:n[3],isInstanceAttr:e}}if(n=e.match(f)){const e=n[1],t={width:"float",position:"vec4",orientation:"bool"}[e],r=n[2],o=n[3].split(",").map((e=>e.trim())).filter((e=>!!e)),i=(e,n,t)=>`${r}(${o.map((r=>e.attrs.get(r).isInstanceAttr?r:(t||"")+r+n)).join(",")})`;return{type:"property",property:e,returnType:t,name:r,inputs:o,generate:i}}if(n=e.match(p)){const e="extrapolate"===n[1],t=n[2],r=n[3],o=n[4],i=n[5].split(",").map((e=>e.trim())).filter((e=>!!e)),s=(n,t,s,a)=>{const f=e?t:`clamp(${t},0.0,1.0)`;return`${r}=${o}(${i.map((e=>`mix(${e+s},${e+a},${f})`)).join(",")});`};return{type:"varying",returnType:t,name:r,getter:o,inputs:i,generate:s}}if(n=e.match(c)){return{type:"postproject",name:n[1]}}throw new Error(`Unrecognized lines pragma:"${e}"`)}function u(e){let n;const t=new Map,r=new Map;for(const i of e)"attribute"===i.type?(t.set(i.name,i),i.vertexUsage=o.NONE,i.endpointUsage=o.NONE):"varying"===i.type?r.set(i.name,i):"postproject"===i.type&&(n=i.name);let i,s,a;for(const n of e)if("property"===n.type){switch(n.property){case"width":if(i)throw new Error(`Unexpected duplicate pragma for property "${n.property}"`);i=n;break;case"position":if(s)throw new Error(`Unexpected duplicate pragma for property "${n.property}"`);s=n;break;case"orientation":if(a)throw new Error(`Unexpected duplicate pragma for property "${n.property}"`);a=n;break;default:throw new Error(`Invalid pragma property "${n.property}"`)}for(const e of n.inputs)if(!t.has(e))throw new Error(`Missing attribute ${e} of property ${n.property}`)}for(const n of e)if(n.inputs)for(const e of n.inputs){const r=t.get(e);r.isInstanceAttr?(r.vertexUsage=o.PER_INSTANCE,r.endpointUsage=o.PER_INSTANCE):"property"!==n.type&&"varying"!==n.type||("position"===n.property?(r.vertexUsage|=o.EXTENDED,r.endpointUsage|=o.EXTENDED):"orientation"===n.property?r.endpointUsage|=o.PER_INSTANCE:(r.endpointUsage|=o.REGULAR,r.vertexUsage|=o.REGULAR))}return{varyings:r,attrs:t,width:i,position:s,orientation:a,postproject:n}}const m=[];m[5120]=1,m[5122]=2,m[5124]=4,m[5121]=1,m[5123]=2,m[5125]=4,m[5126]=4;var v={int8:5120,uint8:5121,int16:5122,uint16:5123,int32:5124,uint32:5125,float:5126,float32:5126},h=function(e,n,t){const r={};if(!n)return r;for(let[o,i]of e.attrs){const e=n[o];if(!(t?i.endpointUsage:i.vertexUsage))continue;const s={buffer:null,dimension:i.dimension,offset:0,type:NaN,stride:NaN,divisor:1,normalized:!1,bytesPerElement:NaN};if(!e)throw new Error(`Missing buffer for ${t?"endpoint":"vertex"} attribute '${o}'`);if("buffer"===e._reglType)s.buffer=e,s.type=s.buffer._buffer.dtype;else{if(!e.buffer||"buffer"!==e.buffer._reglType)throw new Error(`Invalid buffer for attribute '${o}'. Be sure to wrap in regl.buffer().`);if(s.buffer=e.buffer,b(e,"dimension")&&e.dimension!==s.dimension)throw new Error(`Size of attribute(${e.dimension})does not match dimension specified in shader pragma(${i.dimension})`);b(e,"offset")&&(s.offset=e.offset),b(e,"type")?s.type=y[e.type]:s.type=s.buffer._buffer.dtype,b(e,"divisor")&&(s.divisor=e.divisor),b(e,"normalized")&&(s.normalized=!!e.normalized),b(e,"stride")&&(s.stride=e.stride)}s.bytesPerElement=g[s.type],Number.isNaN(s.stride)&&(s.stride=s.bytesPerElement*i.dimension),r[o]=s}return r};const g=m,y=v;function b(e,n){return Object.prototype.hasOwnProperty.call(e,n)}const C=[];C[1]="float",C[2]="vec2",C[3]="vec3",C[4]="vec4";var w=function(e,n,t){const r=t?["B","C","D"]:["A","B","C","D"],o=[],i=[];return e.attrs.forEach(((e,n)=>{const s=t?e.endpointUsage:e.vertexUsage;if(!s)return;const a=[];function f(r,o){const f=n+o;if(a.push(f),t){const t=s&x.PER_INSTANCE?1:3;i.push({name:f,spec:{buffer:(e,t)=>t.buffers[n].buffer,offset:e.isInstanceAttr?(e,t)=>t.buffers[n].offset+t.buffers[n].stride*r:(e,t)=>t.buffers[n].offset+t.buffers[n].stride*((t.orientation!==_.CAP_START&&t.splitCaps?3:0)+r),stride:(e,r)=>r.buffers[n].stride*t*(r.splitCaps?2:1),divisor:(t,r)=>(e.isInstanceAttr?1:r.instances)*r.buffers[n].divisor,normalized:(e,t)=>void 0!==t.buffers[n].normalized&&t.buffers[n].normalized,type:(e,t)=>{const r=t.buffers[n];return $.get(void 0===r.type?r.buffer._buffer.dtype:r.type)}}})}else i.push({name:f,spec:{buffer:(e,t)=>t.buffers[n].buffer,offset:(e,t)=>t.buffers[n].offset+t.buffers[n].stride*r,stride:(e,t)=>t.buffers[n].stride,divisor:(t,r)=>(e.isInstanceAttr?1:r.instances)*r.buffers[n].divisor,normalized:(e,t)=>void 0!==t.buffers[n].normalized&&t.buffers[n].normalized,type:(e,t)=>{const r=t.buffers[n];return $.get(void 0===r.type?r.buffer._buffer.dtype:r.type)}}})}if(s&x.PER_INSTANCE&&f(0,""),s&x.REGULAR||s&x.EXTENDED)for(let e=0;e<r.length;e++){const n=r[e];(s&x.EXTENDED||"D"!==n&&"A"!==n)&&f(e,n)}o.push(`attribute ${A[e.dimension]} ${a.join(",")};`)})),e.varyings.forEach(((e,n)=>{o.push(`varying ${e.returnType} ${n};`)})),{glsl:o.join("\n"),attrs:i}};const x=r,B=v,A=C,_=e,$=new Map(Object.entries(B).map((e=>e.reverse())));const E=t,D=i,T=h,I=w,R=function(e,n,t){return function(r){if(!r)return t;if(-1===n.indexOf(r))throw new Error(`Invalid ${e} type. Valid options are:${n.join(",")}.`);return r}},j=e;var N=X;X.CAP_START=j.CAP_START,X.CAP_END=j.CAP_END;const P=new Set(["attributes","elements"]),S=["round","bevel","miter"],M=["round","square","none"],k=[1,1],U=[2,2/Math.sqrt(3)],z=32,L=16384,O=1,q=2,G=4;function H(e,n,t){return(e?O:0)+(n?q:0)+(t?G:0)}function X(e,n={}){if(!e.hasExtension("ANGLE_instanced_arrays"))throw new Error("regl-gpu-lines requries the ANGLE_instanced_arrays extension");const{vert:t=null,frag:r=null,debug:o=!1,reorder:i=!1}=n;e._gpuLinesCache||(e._gpuLinesCache={});const s=e._gpuLinesCache,a={...n},f=n.uniforms||{};for(const e of["vert","frag","debug","reorder","uniforms"])delete a[e];if(Object.keys(a).forEach((e=>{if(P.has(e))throw new Error(`Invalid parameter '${e}'. Parameters ${[...P].map((e=>`'${e}'`)).join(",")} may not be forwarded to regl.`)})),!t)throw new Error("Missing vertex shader,`vert`");if(!r)throw new Error("Missing fragment shader,`frag`");const p=D(t),c=I(p,e,!1),l=I(p,e,!0),d=[];o&&(s.debugInstanceIDBuffer||(s.debugInstanceIDBuffer=e.buffer(new Uint16Array([...Array(L).keys()]))),d.push({name:"debugInstanceID",spec:{buffer:s.debugInstanceIDBuffer,divisor:(e,n)=>n.instances}})),s.indexBuffer||(s.indexBuffer=e.buffer(new Uint8Array([...Array(4*z+6).keys()]))),d.push({name:"index",spec:{buffer:s.indexBuffer,divisor:0}});const u=R("join",S,"miter"),m=R("cap",M,"square"),v=new Map;function h(n){return v.has(n)||v.set(n,E(e,n&O,n&q,n&G,p,r,c,l,d,a,f,o)),v.get(n)}const g=[];function y(...e){g.push.apply(g,e)}function b(){i&&g.sort((function(e,n){return e.featureMask-n.featureMask}));let e=0;const n=[];for(;e<g.length;){const{featureMask:t,props:r}=g[e];for(n.push(r);++e<g.length&&g[e].featureMask===t;)n.push(g[e].props);h(t)(n),n.length=0}g.length=0}const C=function(e){if(e){Array.isArray(e)||(e=[e]);for(const n of e){const e=u(n.join),t=m(n.cap),r=!!n.vao;let o=void 0===n.capResolution?12:n.capResolution;"square"===t?o=3:"none"===t&&(o=1);let i=1;"round"===e&&(i=void 0===n.joinResolution?8:n.joinResolution),o*=2,i*=2;const s="bevel"===e?1:void 0===n.miterLimit?4:n.miterLimit,a="square"===t?U:k,f=!!n.insertCaps,c={joinRes2:i,capRes2:o,capScale:a,join:e,miterLimit:s,insertCaps:f};if(n.endpointCount){const e={instances:1,count:n.endpointCount,...n,...c};let t=H(!0,f,r);if(r)if(p.orientation){const n={vao:e.vao.endpoints};y({featureMask:t,props:{...e,...n}})}else{const n={vao:e.vao.startCaps},r={vao:e.vao.endCaps};y({featureMask:t,props:{...e,...n,orientation:j.CAP_START,splitCaps:!0}},{featureMask:t,props:{...e,...r,orientation:j.CAP_END,splitCaps:!0}})}else e.buffers=T(p,n.endpointAttributes,!0),p.orientation?y({featureMask:t,props:{...e,splitCaps:!1}}):y({featureMask:t,props:{...e,orientation:j.CAP_START,splitCaps:!0}},{featureMask:t,props:{...e,orientation:j.CAP_END,splitCaps:!0}})}if(void 0===n.instances&&(n.instances=1),n.vertexCount){const e=H(!1,f,r),t={count:n.vertexCount,...n,...c};r?t.vao=n.vao.vertices:t.buffers=T(p,n.vertexAttributes,!1),y({featureMask:e,props:t})}b()}}};return C.vao=function(n){const t={},r=[["vertices",c.attrs,n.vertexAttributes,!1]];p.orientation?r.push(["endpoints",l.attrs,n.endpointAttributes,!0,!1,null]):r.push(["startCaps",l.attrs,n.endpointAttributes,!0,!0,j.CAP_START],["endCaps",l.attrs,n.endpointAttributes,!0,!0,j.CAP_END]);for(const[n,o,i,s,a,f]of r){if(!i)continue;const r={buffers:T(p,i,s),splitCaps:a,orientation:f},c=[];for(const e of d.concat(o)){const n={};for(const t of["buffer","divisor","offset","stride","normalized","dimension"]){let o=e.spec[t];o&&o.data&&(o=o.data),"function"==typeof o&&(o=o({},r)),void 0!==o&&(n[t]=o)}c.push(n)}t[n]=e.vao(c)}return t.destroy=function(){for(const[e]of r)t[e]&&(t[e].destroy(),delete t[e])},t},C}return N}));