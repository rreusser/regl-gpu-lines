<!DOCTYPE html><html lang="en" dir="ltr"><head><title>regl-gpu-lines tests</title><meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <script src="https://unpkg.com/regl@2.1.0/dist/regl.js"></script>
          <script src="https://unpkg.com/regl-gpu-lines@latest"></script>
          </head><body>
<script>const fixtures = {"miter/basic":{"name":"miter/basic","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"threshold\": 0.1,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.0],\n      [-0.5, 0.0],\n      [0.3, 0.7],\n      [0.8, 0.7],\n      [-0.8, -0.7],\n      [-0.3, -0.7],\n      [0.5, 0.0],\n      [0.8, 0.0]\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.0],\n        [-0.5, 0.0],\n        [0.3, 0.7]\n      ], [\n        [0.8, 0.0],\n        [0.5, 0.0],\n        [-0.3, -0.7]\n      ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"miter\",\n    \"cap\": \"square\"\n  }\n}\n"},"miter/dash/extrapolate":{"name":"miter/dash/extrapolate","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float t\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"#pragma lines: extrapolate varying float t = getT(t)\",\n      \"uniform float width;\",\n      \"float getWidth() { return width; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\",\n      \"float getT(float t) { return t; }\"\n    ],\n    \"frag\": [\n      \"precision highp float;\",\n      \"varying float t;\",\n      \"uniform float width;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(vec3(fract(t) > 0.5 ? 1.0 : 0.0), 0.5);\",\n      \"}\"\n    ],\n    \"uniforms\": {\n      \"width\": 15\n    },\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.0],\n      [-0.5, 0.0],\n      [0.3, 0.7],\n      [0.8, 0.7],\n      [-0.8, -0.7],\n      [-0.3, -0.7],\n      [0.5, 0.0],\n      [0.8, 0.0]\n    ],\n    \"t\": [0, 4, 16, 22, 46, 52, 64, 68]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.0],\n        [-0.5, 0.0],\n        [0.3, 0.7]\n      ], [\n        [0.8, 0.0],\n        [0.5, 0.0],\n        [-0.3, -0.7]\n      ]\n    ],\n    \"t\": [\n      [ 0, 4, 16 ],\n      [ 68, 34, 52 ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"miter\",\n    \"cap\": \"square\"\n  }\n}\n"},"miter/dash/no-extrapolate":{"name":"miter/dash/no-extrapolate","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float t\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"#pragma lines: varying float t = getT(t)\",\n      \"uniform float width;\",\n      \"float getWidth() { return width; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\",\n      \"float getT(float t) { return t; }\"\n    ],\n    \"frag\": [\n      \"precision highp float;\",\n      \"varying float t;\",\n      \"uniform float width;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(vec3(fract(t) > 0.5 ? 1.0 : 0.0), 0.5);\",\n      \"}\"\n    ],\n    \"uniforms\": {\n      \"width\": 15\n    },\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.0],\n      [-0.5, 0.0],\n      [0.3, 0.7],\n      [0.8, 0.7],\n      [-0.8, -0.7],\n      [-0.3, -0.7],\n      [0.5, 0.0],\n      [0.8, 0.0]\n    ],\n    \"t\": [0, 4, 16, 22, 46, 52, 64, 68]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.0],\n        [-0.5, 0.0],\n        [0.3, 0.7]\n      ], [\n        [0.8, 0.0],\n        [0.5, 0.0],\n        [-0.3, -0.7]\n      ]\n    ],\n    \"t\": [\n      [ 0, 4, 16 ],\n      [ 68, 34, 52 ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"miter\",\n    \"cap\": \"square\"\n  }\n}\n"},"miter/degenerate":{"name":"miter/degenerate","fixture":"{\n  \"width\": 128,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.2);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [0, 0],\n      [0.8, 0],\n      [0,0],\n      [0,-0.8],\n      [0,0],\n      [-0.8,0],\n      [0,0],\n      [0,0.8],\n      [0,0],\n      [0.6, 0.6],\n      [0, 0],\n      [-0.6, 0.6],\n      [0, 0],\n      [-0.6, -0.6],\n      [0, 0],\n      [0.6, -0.6],\n      [0,0],\n      [-0.1, 0.1]\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [0, 0],\n        [0.8, 0],\n        [0,0]\n      ], [\n        [-0.1, 0.1],\n        [0,0],\n        [0.6, -0.6]\n      ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"miter\",\n    \"cap\": \"square\",\n    \"capResolution\": 4,\n    \"joinResolution\": 4\n  }\n}\n"},"miter/depth":{"name":"miter/depth","fixture":"{\n  \"width\": 128,\n  \"height\": 64,\n  \"threshold\": 0.1,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec3 xyz\",\n      \"#pragma lines: attribute vec3 color\",\n      \"#pragma lines: position = getPosition(xyz)\",\n      \"#pragma lines: varying vec3 color = getColor(color)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 10.0; }\",\n      \"vec3 getColor(vec3 color) { return color; }\",\n      \"vec4 getPosition(vec3 xyz) { return vec4(xyz, 1); }\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"varying vec3 color;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(color,1);\",\n      \"}\"\n    ],\n    \"depth\": {\n      \"enable\": true\n    }\n  },\n  \"vertexAttributes\": {\n    \"xyz\": [\n      [-0.6, -0.6, 0.7],\n      [0.0, 0.6, 0.7],\n      [0.6, -0.6, 0.7],\n      [0.6, 0.6, 0.7],\n      [0.0, -0.6, 0.7],\n      [-0.6, 0.6, -0.7]\n    ],\n    \"color\": [\n      [0.8,0.2,0.2],\n      [0.8,0.2,0.2],\n      [0.8,0.2,0.2],\n      [0.2,0.2,0.8],\n      [0.2,0.2,0.8],\n      [0.2,0.2,0.8]\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xyz\": [\n      [\n        [-0.6, -0.6, 0.7],\n        [0.0, 0.6, 0.7],\n        [0.6, -0.6, 0.7]\n      ], [\n        [-0.6, 0.6, -0.7],\n        [0.0, -0.6, 0.7],\n        [0.6, 0.6, 0.7]\n      ]\n    ],\n    \"color\": [\n      [\n        [0.8,0.2,0.2],\n        [0.8,0.2,0.2],\n        [0.8,0.2,0.2]\n      ], [\n        [0.2,0.2,0.8],\n        [0.2,0.2,0.8],\n        [0.2,0.2,0.8]\n      ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"miter\",\n    \"cap\": \"square\"\n  }\n}\n"},"miter/insert-caps/nan":{"name":"miter/insert-caps/nan","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy) {\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [null, null],\n\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [null, null],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [null, null],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5],\n\n      [null, null]\n    ]\n  },\n  \"data\": {\n    \"insertCaps\": true,\n    \"join\": \"miter\",\n    \"cap\": \"round\"\n  }\n}\n"},"miter/insert-caps/none":{"name":"miter/insert-caps/none","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [0,0],\n\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5],\n\n      [0,0]\n    ],\n    \"break\": [\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1\n    ]\n  },\n  \"data\": {\n    \"insertCaps\": true,\n    \"join\": \"miter\",\n    \"cap\": \"none\"\n  }\n}\n"},"miter/insert-caps/round":{"name":"miter/insert-caps/round","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [0,0],\n\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5],\n\n      [0,0]\n    ],\n    \"break\": [\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1\n    ]\n  },\n  \"data\": {\n    \"insertCaps\": true,\n    \"join\": \"miter\",\n    \"cap\": \"round\"\n  }\n}\n"},"miter/insert-caps/square":{"name":"miter/insert-caps/square","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [0,0],\n\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5],\n\n      [0,0]\n    ],\n    \"break\": [\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1\n    ]\n  },\n  \"data\": {\n    \"insertCaps\": true,\n    \"join\": \"miter\",\n    \"cap\": \"square\"\n  }\n}\n"},"miter/manual-caps/none":{"name":"miter/manual-caps/none","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5]\n    ],\n    \"break\": [\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.5],\n        [-0.3, 0.7],\n        [0.3, 0.5]\n      ], [\n        [0.8, 0.7],\n        [0.3, 0.5],\n        [-0.3, 0.7]\n      ], [\n        [-0.8, -0.1],\n        [-0.3, 0.1],\n        [0.3, -0.1]\n      ], [\n        [0.8, 0.1],\n        [0.3, -0.1],\n        [-0.3, 0.1]\n      ], [\n        [-0.8, -0.7],\n        [-0.3, -0.5],\n        [0.3, -0.7]\n      ], [\n        [0.8, -0.5],\n        [0.3, -0.7],\n        [-0.3, -0.5]\n      ]\n    ],\n    \"break\": [\n      [0, 0, 0],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 0]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"none\"\n  }\n}\n"},"miter/manual-caps/round":{"name":"miter/manual-caps/round","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5]\n    ],\n    \"break\": [\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.5],\n        [-0.3, 0.7],\n        [0.3, 0.5]\n      ], [\n        [0.8, 0.7],\n        [0.3, 0.5],\n        [-0.3, 0.7]\n      ], [\n        [-0.8, -0.1],\n        [-0.3, 0.1],\n        [0.3, -0.1]\n      ], [\n        [0.8, 0.1],\n        [0.3, -0.1],\n        [-0.3, 0.1]\n      ], [\n        [-0.8, -0.7],\n        [-0.3, -0.5],\n        [0.3, -0.7]\n      ], [\n        [0.8, -0.5],\n        [0.3, -0.7],\n        [-0.3, -0.5]\n      ]\n    ],\n    \"break\": [\n      [0, 0, 0],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 0]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\"\n  }\n}\n"},"miter/manual-caps/square":{"name":"miter/manual-caps/square","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5]\n    ],\n    \"break\": [\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.5],\n        [-0.3, 0.7],\n        [0.3, 0.5]\n      ], [\n        [0.8, 0.7],\n        [0.3, 0.5],\n        [-0.3, 0.7]\n      ], [\n        [-0.8, -0.1],\n        [-0.3, 0.1],\n        [0.3, -0.1]\n      ], [\n        [0.8, 0.1],\n        [0.3, -0.1],\n        [-0.3, 0.1]\n      ], [\n        [-0.8, -0.7],\n        [-0.3, -0.5],\n        [0.3, -0.7]\n      ], [\n        [0.8, -0.5],\n        [0.3, -0.7],\n        [-0.3, -0.5]\n      ]\n    ],\n    \"break\": [\n      [0, 0, 0],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 0]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"square\"\n  }\n}\n"},"miter/sdf":{"name":"miter/sdf","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"uniform float width;\",\n      \"float getWidth() { return width; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\"\n    ],\n    \"frag\": [\n      \"precision highp float;\",\n      \"varying vec3 lineCoord;\",\n      \"uniform float width;\",\n      \"float linearstep(float a, float b, float x) { return clamp((x - a) / (b - a), 0.0, 1.0); }\",\n      \"void main () {\",\n      \"  float sdf = 0.5 * width * max(abs(lineCoord.x), abs(lineCoord.y));\",\n      \"  float aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);\",\n      \"  float border = linearstep(width * 0.5 - 4.5, width * 0.5 - 3.5, sdf);\",\n      \"  float alpha = aa * mix(0.2, 1.0, border);\",\n      \"  gl_FragColor = vec4(vec3(0), alpha);\",\n      \"}\"\n    ],\n    \"uniforms\": {\n      \"width\": 20\n    },\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.0],\n      [-0.5, 0.0],\n      [0.3, 0.7],\n      [0.8, 0.7],\n      [-0.8, -0.7],\n      [-0.3, -0.7],\n      [0.5, 0.0],\n      [0.8, 0.0]\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.0],\n        [-0.5, 0.0],\n        [0.3, 0.7]\n      ], [\n        [0.8, 0.0],\n        [0.5, 0.0],\n        [-0.3, -0.7]\n      ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"miter\",\n    \"cap\": \"square\"\n  }\n}\n"},"round/basic":{"name":"round/basic","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.0],\n      [-0.5, 0.0],\n      [0.3, 0.7],\n      [0.8, 0.7],\n      [-0.8, -0.7],\n      [-0.3, -0.7],\n      [0.5, 0.0],\n      [0.8, 0.0]\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.0],\n        [-0.5, 0.0],\n        [0.3, 0.7]\n      ], [\n        [0.8, 0.0],\n        [0.5, 0.0],\n        [-0.3, -0.7]\n      ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\"\n  }\n}\n"},"round/dash/extrapolate":{"name":"round/dash/extrapolate","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float t\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"#pragma lines: extrapolate varying float t = getT(t)\",\n      \"uniform float width;\",\n      \"float getWidth() { return width; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\",\n      \"float getT(float t) { return t; }\"\n    ],\n    \"frag\": [\n      \"precision highp float;\",\n      \"varying float t;\",\n      \"uniform float width;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(vec3(fract(t) > 0.5 ? 1.0 : 0.0), 0.5);\",\n      \"}\"\n    ],\n    \"uniforms\": {\n      \"width\": 15\n    },\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.0],\n      [-0.5, 0.0],\n      [0.3, 0.7],\n      [0.8, 0.7],\n      [-0.8, -0.7],\n      [-0.3, -0.7],\n      [0.5, 0.0],\n      [0.8, 0.0]\n    ],\n    \"t\": [0, 4, 16, 22, 46, 52, 64, 68]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.0],\n        [-0.5, 0.0],\n        [0.3, 0.7]\n      ], [\n        [0.8, 0.0],\n        [0.5, 0.0],\n        [-0.3, -0.7]\n      ]\n    ],\n    \"t\": [\n      [ 0, 4, 16 ],\n      [ 68, 34, 52 ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\"\n  }\n}\n"},"round/dash/no-extrapolate":{"name":"round/dash/no-extrapolate","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float t\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"#pragma lines: varying float t = getT(t)\",\n      \"uniform float width;\",\n      \"float getWidth() { return width; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\",\n      \"float getT(float t) { return t; }\"\n    ],\n    \"frag\": [\n      \"precision highp float;\",\n      \"varying float t;\",\n      \"uniform float width;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(vec3(fract(t) > 0.5 ? 1.0 : 0.0), 0.5);\",\n      \"}\"\n    ],\n    \"uniforms\": {\n      \"width\": 15\n    },\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.0],\n      [-0.5, 0.0],\n      [0.3, 0.7],\n      [0.8, 0.7],\n      [-0.8, -0.7],\n      [-0.3, -0.7],\n      [0.5, 0.0],\n      [0.8, 0.0]\n    ],\n    \"t\": [0, 4, 16, 22, 46, 52, 64, 68]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.0],\n        [-0.5, 0.0],\n        [0.3, 0.7]\n      ], [\n        [0.8, 0.0],\n        [0.5, 0.0],\n        [-0.3, -0.7]\n      ]\n    ],\n    \"t\": [\n      [ 0, 4, 16 ],\n      [ 68, 34, 52 ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\"\n  }\n}\n"},"round/degenerate":{"name":"round/degenerate","fixture":"{\n  \"width\": 128,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.2);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [0, 0],\n      [0.8, 0],\n      [0,0],\n      [0,-0.8],\n      [0,0],\n      [-0.8,0],\n      [0,0],\n      [0,0.8],\n      [0,0],\n      [0.6, 0.6],\n      [0, 0],\n      [-0.6, 0.6],\n      [0, 0],\n      [-0.6, -0.6],\n      [0, 0],\n      [0.6, -0.6],\n      [0,0],\n      [-0.1, 0.1]\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [0, 0],\n        [0.8, 0],\n        [0,0]\n      ], [\n        [-0.1, 0.1],\n        [0,0],\n        [0.6, -0.6]\n      ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\",\n    \"capResolution\": 4,\n    \"joinResolution\": 4\n  }\n}\n"},"round/depth":{"name":"round/depth","fixture":"{\n  \"width\": 128,\n  \"height\": 64,\n  \"threshold\": 0.1,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec3 xyz\",\n      \"#pragma lines: attribute vec3 color\",\n      \"#pragma lines: position = getPosition(xyz)\",\n      \"#pragma lines: varying vec3 color = getColor(color)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 10.0; }\",\n      \"vec3 getColor(vec3 color) { return color; }\",\n      \"vec4 getPosition(vec3 xyz) { return vec4(xyz, 1); }\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"varying vec3 color;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(color,1);\",\n      \"}\"\n    ],\n    \"depth\": {\n      \"enable\": true\n    }\n  },\n  \"vertexAttributes\": {\n    \"xyz\": [\n      [-0.6, -0.6, 0.7],\n      [0.0, 0.6, 0.7],\n      [0.6, -0.6, 0.7],\n      [0.6, 0.6, 0.7],\n      [0.0, -0.6, 0.7],\n      [-0.6, 0.6, -0.7]\n    ],\n    \"color\": [\n      [0.8,0.2,0.2],\n      [0.8,0.2,0.2],\n      [0.8,0.2,0.2],\n      [0.2,0.2,0.8],\n      [0.2,0.2,0.8],\n      [0.2,0.2,0.8]\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xyz\": [\n      [\n        [-0.6, -0.6, 0.7],\n        [0.0, 0.6, 0.7],\n        [0.6, -0.6, 0.7]\n      ], [\n        [-0.6, 0.6, -0.7],\n        [0.0, -0.6, 0.7],\n        [0.6, 0.6, 0.7]\n      ]\n    ],\n    \"color\": [\n      [\n        [0.8,0.2,0.2],\n        [0.8,0.2,0.2],\n        [0.8,0.2,0.2]\n      ], [\n        [0.2,0.2,0.8],\n        [0.2,0.2,0.8],\n        [0.2,0.2,0.8]\n      ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\"\n  }\n}\n"},"round/insert-caps/none":{"name":"round/insert-caps/none","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [0,0],\n\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5],\n\n      [0,0]\n    ],\n    \"break\": [\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1\n    ]\n  },\n  \"data\": {\n    \"insertCaps\": true,\n    \"join\": \"round\",\n    \"cap\": \"none\"\n  }\n}\n"},"round/insert-caps/round":{"name":"round/insert-caps/round","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    },\n    \"cull\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [0, 0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5],\n\n      [0, 0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0, 0],\n\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0, 0]\n    ],\n    \"break\": [\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1\n    ]\n  },\n  \"data\": {\n    \"insertCaps\": true,\n    \"join\": \"round\",\n    \"cap\": \"round\"\n  }\n}\n"},"round/insert-caps/square":{"name":"round/insert-caps/square","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [0,0],\n\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5],\n\n      [0,0]\n    ],\n    \"break\": [\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1\n    ]\n  },\n  \"data\": {\n    \"insertCaps\": true,\n    \"join\": \"round\",\n    \"cap\": \"square\"\n  }\n}\n"},"round/manual-caps/none":{"name":"round/manual-caps/none","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5]\n    ],\n    \"break\": [\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.5],\n        [-0.3, 0.7],\n        [0.3, 0.5]\n      ], [\n        [0.8, 0.7],\n        [0.3, 0.5],\n        [-0.3, 0.7]\n      ], [\n        [-0.8, -0.1],\n        [-0.3, 0.1],\n        [0.3, -0.1]\n      ], [\n        [0.8, 0.1],\n        [0.3, -0.1],\n        [-0.3, 0.1]\n      ], [\n        [-0.8, -0.7],\n        [-0.3, -0.5],\n        [0.3, -0.7]\n      ], [\n        [0.8, -0.5],\n        [0.3, -0.7],\n        [-0.3, -0.5]\n      ]\n    ],\n    \"break\": [\n      [0, 0, 0],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 0]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"none\"\n  }\n}\n"},"round/manual-caps/round":{"name":"round/manual-caps/round","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5]\n    ],\n    \"break\": [\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.5],\n        [-0.3, 0.7],\n        [0.3, 0.5]\n      ], [\n        [0.8, 0.7],\n        [0.3, 0.5],\n        [-0.3, 0.7]\n      ], [\n        [-0.8, -0.1],\n        [-0.3, 0.1],\n        [0.3, -0.1]\n      ], [\n        [0.8, 0.1],\n        [0.3, -0.1],\n        [-0.3, 0.1]\n      ], [\n        [-0.8, -0.7],\n        [-0.3, -0.5],\n        [0.3, -0.7]\n      ], [\n        [0.8, -0.5],\n        [0.3, -0.7],\n        [-0.3, -0.5]\n      ]\n    ],\n    \"break\": [\n      [0, 0, 0],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 0]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\"\n  }\n}\n"},"round/manual-caps/square":{"name":"round/manual-caps/square","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: attribute float break\",\n      \"#pragma lines: position = getPosition(xy, break)\",\n      \"#pragma lines: width = getWidth()\",\n      \"float getWidth() { return 20.0; }\",\n      \"vec4 getPosition(vec2 xy, float isBreak) {\",\n      \"  if (isBreak > 0.0) return vec4(0);\",\n      \"  return vec4(xy, 0, 1);\",\n      \"}\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,0.5);\",\n      \"}\"\n    ],\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.5],\n      [-0.3, 0.7],\n      [0.3, 0.5],\n      [0.8, 0.7],\n\n      [0,0],\n\n      [-0.8, -0.1],\n      [-0.3, 0.1],\n      [0.3, -0.1],\n      [0.8, 0.1],\n\n      [0,0],\n\n      [-0.8, -0.7],\n      [-0.3, -0.5],\n      [0.3, -0.7],\n      [0.8, -0.5]\n    ],\n    \"break\": [\n      0,0,0,0,\n      1,\n      0,0,0,0,\n      1,\n      0,0,0,0\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.5],\n        [-0.3, 0.7],\n        [0.3, 0.5]\n      ], [\n        [0.8, 0.7],\n        [0.3, 0.5],\n        [-0.3, 0.7]\n      ], [\n        [-0.8, -0.1],\n        [-0.3, 0.1],\n        [0.3, -0.1]\n      ], [\n        [0.8, 0.1],\n        [0.3, -0.1],\n        [-0.3, 0.1]\n      ], [\n        [-0.8, -0.7],\n        [-0.3, -0.5],\n        [0.3, -0.7]\n      ], [\n        [0.8, -0.5],\n        [0.3, -0.7],\n        [-0.3, -0.5]\n      ]\n    ],\n    \"break\": [\n      [0, 0, 0],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 1],\n      [0, 0, 0]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"square\"\n  }\n}\n"},"round/postproject":{"name":"round/postproject","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"#pragma lines: postproject = postprojectPosition\",\n      \"uniform float width;\",\n      \"uniform mat4 projectionView;\",\n      \"float getWidth() { return width; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\",\n      \"vec4 postprojectPosition(vec4 position) { return projectionView * position; }\"\n    ],\n    \"frag\": [\n      \"precision lowp float;\",\n      \"void main () {\",\n      \"  gl_FragColor = vec4(0,0,0,1);\",\n      \"}\"\n    ],\n    \"depth\": { \"enable\": true },\n    \"uniforms\": {\n      \"width\": 0.10,\n      \"projectionView\": [\n        -0.022149166092276573, -0.646040678024292, -0.9652843475341797, -0.9633557200431824,\n        1.2069035768508911, -0.011856176890432835, -0.017714954912662506, -0.01767956092953682,\n        0, 2.3261380195617676, -0.26817968487739563, -0.26764386892318726,\n        0, 0, 1.8518742322921753, 1.8681541681289673\n      ]\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [1, 0],\n      [-0.22252093395631434, 0.9749279121818236],\n      [-0.9009688679024191, -0.433883739117558],\n      [0.6234898018587334, -0.7818314824680299],\n      [0.6234898018587337, 0.7818314824680297],\n      [-0.9009688679024189, 0.43388373911755845],\n      [-0.2225209339563148, -0.9749279121818235],\n      [1, 0],\n      [-0.22252093395631387, 0.9749279121818237],\n      [-0.9009688679024194, -0.43388373911755757]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\",\n    \"viewportSize\": [1, 1]\n  }\n}\n"},"round/sdf":{"name":"round/sdf","fixture":"{\n  \"width\": 256,\n  \"height\": 128,\n  \"command\": {\n    \"vert\": [\n      \"precision highp float;\",\n      \"#pragma lines: attribute vec2 xy\",\n      \"#pragma lines: position = getPosition(xy)\",\n      \"#pragma lines: width = getWidth()\",\n      \"uniform float width;\",\n      \"float getWidth() { return width; }\",\n      \"vec4 getPosition(vec2 xy) { return vec4(xy, 0, 1); }\"\n    ],\n    \"frag\": [\n      \"precision highp float;\",\n      \"varying vec3 lineCoord;\",\n      \"uniform float width;\",\n      \"float linearstep(float a, float b, float x) { return clamp((x - a) / (b - a), 0.0, 1.0); }\",\n      \"void main () {\",\n      \"  float sdf = 0.5 * width * length(lineCoord.xy);\",\n      \"  float aa = linearstep(width * 0.5, width * 0.5 - 1.0, sdf);\",\n      \"  float border = linearstep(width * 0.5 - 4.5, width * 0.5 - 3.5, sdf);\",\n      \"  float alpha = aa * mix(0.2, 1.0, border);\",\n      \"  gl_FragColor = vec4(vec3(0), alpha);\",\n      \"}\"\n    ],\n    \"uniforms\": {\n      \"width\": 20\n    },\n    \"blend\": {\n      \"enable\": true,\n      \"func\": {\n        \"srcRGB\": \"src alpha\",\n        \"srcAlpha\": 1,\n        \"dstRGB\": \"one minus src alpha\",\n        \"dstAlpha\": 1\n      }\n    },\n    \"depth\": {\n      \"enable\": false\n    }\n  },\n  \"vertexAttributes\": {\n    \"xy\": [\n      [-0.8, 0.0],\n      [-0.5, 0.0],\n      [0.3, 0.7],\n      [0.8, 0.7],\n      [-0.8, -0.7],\n      [-0.3, -0.7],\n      [0.5, 0.0],\n      [0.8, 0.0]\n    ]\n  },\n  \"endpointAttributes\": {\n    \"xy\": [\n      [\n        [-0.8, 0.0],\n        [-0.5, 0.0],\n        [0.3, 0.7]\n      ], [\n        [0.8, 0.0],\n        [0.5, 0.0],\n        [-0.3, -0.7]\n      ]\n    ]\n  },\n  \"data\": {\n    \"join\": \"round\",\n    \"cap\": \"round\"\n  }\n}\n"}};</script>
<script>(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

module.exports = pixelmatch;

const defaultOptions = {
    threshold: 0.1,         // matching threshold (0 to 1); smaller is more sensitive
    includeAA: false,       // whether to skip anti-aliasing detection
    alpha: 0.1,             // opacity of original image in diff output
    aaColor: [255, 255, 0], // color of anti-aliased pixels in diff output
    diffColor: [255, 0, 0], // color of different pixels in diff output
    diffColorAlt: null,     // whether to detect dark on light differences between img1 and img2 and set an alternative color to differentiate between the two
    diffMask: false         // draw the diff over a transparent background (a mask)
};

function pixelmatch(img1, img2, output, width, height, options) {

    if (!isPixelData(img1) || !isPixelData(img2) || (output && !isPixelData(output)))
        throw new Error('Image data: Uint8Array, Uint8ClampedArray or Buffer expected.');

    if (img1.length !== img2.length || (output && output.length !== img1.length))
        throw new Error('Image sizes do not match.');

    if (img1.length !== width * height * 4) throw new Error('Image data size does not match width/height.');

    options = Object.assign({}, defaultOptions, options);

    // check if images are identical
    const len = width * height;
    const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);
    const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);
    let identical = true;

    for (let i = 0; i < len; i++) {
        if (a32[i] !== b32[i]) { identical = false; break; }
    }
    if (identical) { // fast path if identical
        if (output && !options.diffMask) {
            for (let i = 0; i < len; i++) drawGrayPixel(img1, 4 * i, options.alpha, output);
        }
        return 0;
    }

    // maximum acceptable square distance between two colors;
    // 35215 is the maximum possible value for the YIQ difference metric
    const maxDelta = 35215 * options.threshold * options.threshold;
    let diff = 0;

    // compare each pixel of one image against the other one
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {

            const pos = (y * width + x) * 4;

            // squared YUV distance between colors at this pixel position, negative if the img2 pixel is darker
            const delta = colorDelta(img1, img2, pos, pos);

            // the color difference is above the threshold
            if (Math.abs(delta) > maxDelta) {
                // check it's a real rendering difference or just anti-aliasing
                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) ||
                                           antialiased(img2, x, y, width, height, img1))) {
                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference
                    // note that we do not include such pixels in a mask
                    if (output && !options.diffMask) drawPixel(output, pos, ...options.aaColor);

                } else {
                    // found substantial difference not caused by anti-aliasing; draw it as such
                    if (output) {
                        drawPixel(output, pos, ...(delta < 0 && options.diffColorAlt || options.diffColor));
                    }
                    diff++;
                }

            } else if (output) {
                // pixels are similar; draw background as grayscale image blended with white
                if (!options.diffMask) drawGrayPixel(img1, pos, options.alpha, output);
            }
        }
    }

    // return the number of different pixels
    return diff;
}

function isPixelData(arr) {
    // work around instanceof Uint8Array not working properly in some Jest environments
    return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;
}

// check if a pixel is likely a part of anti-aliasing;
// based on "Anti-aliased Pixel and Intensity Slope Detector" paper by V. Vysniauskas, 2009

function antialiased(img, x1, y1, width, height, img2) {
    const x0 = Math.max(x1 - 1, 0);
    const y0 = Math.max(y1 - 1, 0);
    const x2 = Math.min(x1 + 1, width - 1);
    const y2 = Math.min(y1 + 1, height - 1);
    const pos = (y1 * width + x1) * 4;
    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
    let min = 0;
    let max = 0;
    let minX, minY, maxX, maxY;

    // go through 8 adjacent pixels
    for (let x = x0; x <= x2; x++) {
        for (let y = y0; y <= y2; y++) {
            if (x === x1 && y === y1) continue;

            // brightness delta between the center pixel and adjacent one
            const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);

            // count the number of equal, darker and brighter adjacent pixels
            if (delta === 0) {
                zeroes++;
                // if found more than 2 equal siblings, it's definitely not anti-aliasing
                if (zeroes > 2) return false;

            // remember the darkest pixel
            } else if (delta < min) {
                min = delta;
                minX = x;
                minY = y;

            // remember the brightest pixel
            } else if (delta > max) {
                max = delta;
                maxX = x;
                maxY = y;
            }
        }
    }

    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing
    if (min === 0 || max === 0) return false;

    // if either the darkest or the brightest pixel has 3+ equal siblings in both images
    // (definitely not anti-aliased), this pixel is anti-aliased
    return (hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height)) ||
           (hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height));
}

// check if a pixel has 3+ adjacent pixels of the same color.
function hasManySiblings(img, x1, y1, width, height) {
    const x0 = Math.max(x1 - 1, 0);
    const y0 = Math.max(y1 - 1, 0);
    const x2 = Math.min(x1 + 1, width - 1);
    const y2 = Math.min(y1 + 1, height - 1);
    const pos = (y1 * width + x1) * 4;
    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;

    // go through 8 adjacent pixels
    for (let x = x0; x <= x2; x++) {
        for (let y = y0; y <= y2; y++) {
            if (x === x1 && y === y1) continue;

            const pos2 = (y * width + x) * 4;
            if (img[pos] === img[pos2] &&
                img[pos + 1] === img[pos2 + 1] &&
                img[pos + 2] === img[pos2 + 2] &&
                img[pos + 3] === img[pos2 + 3]) zeroes++;

            if (zeroes > 2) return true;
        }
    }

    return false;
}

// calculate color difference according to the paper "Measuring perceived color difference
// using YIQ NTSC transmission color space in mobile applications" by Y. Kotsarenko and F. Ramos

function colorDelta(img1, img2, k, m, yOnly) {
    let r1 = img1[k + 0];
    let g1 = img1[k + 1];
    let b1 = img1[k + 2];
    let a1 = img1[k + 3];

    let r2 = img2[m + 0];
    let g2 = img2[m + 1];
    let b2 = img2[m + 2];
    let a2 = img2[m + 3];

    if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2) return 0;

    if (a1 < 255) {
        a1 /= 255;
        r1 = blend(r1, a1);
        g1 = blend(g1, a1);
        b1 = blend(b1, a1);
    }

    if (a2 < 255) {
        a2 /= 255;
        r2 = blend(r2, a2);
        g2 = blend(g2, a2);
        b2 = blend(b2, a2);
    }

    const y1 = rgb2y(r1, g1, b1);
    const y2 = rgb2y(r2, g2, b2);
    const y = y1 - y2;

    if (yOnly) return y; // brightness difference only

    const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);
    const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);

    const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;

    // encode whether the pixel lightens or darkens in the sign
    return y1 > y2 ? -delta : delta;
}

function rgb2y(r, g, b) { return r * 0.29889531 + g * 0.58662247 + b * 0.11448223; }
function rgb2i(r, g, b) { return r * 0.59597799 - g * 0.27417610 - b * 0.32180189; }
function rgb2q(r, g, b) { return r * 0.21147017 - g * 0.52261711 + b * 0.31114694; }

// blend semi-transparent color with white
function blend(c, a) {
    return 255 + (c - 255) * a;
}

function drawPixel(output, pos, r, g, b) {
    output[pos + 0] = r;
    output[pos + 1] = g;
    output[pos + 2] = b;
    output[pos + 3] = 255;
}

function drawGrayPixel(img, i, alpha, output) {
    const r = img[i + 0];
    const g = img[i + 1];
    const b = img[i + 2];
    const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);
    drawPixel(output, i, val, val, val);
}

},{}],2:[function(require,module,exports){
const renderFixture = require('../test/util/render-fixture.js');
const pixelmatch = require('pixelmatch');

const h = (type, props, c) => {
  const el = document.createElement(type);
  if (c) (Array.isArray(c) ? c : [c]).forEach(c => el.appendChild(typeof c === 'string' ? document.createTextNode(c) : c));
  return Object.assign(el, props);
}

document.body.appendChild(h('style', {}, `
html { font-family: sans-serif; }
p { line-height: 1.4em; max-width: 640px; }
.actual { border: 1px solid #888 }
.expected { border: 1px solid #23f; }
.diff { border: 1px solid #f23; }
.group { margin-bottom: 1em; }
summary { cursor: pointer; }
`));

const initialFixtureName = window.location.hash.replace(/^#/, '') || Object.keys(fixtures)[0];

const fixtureSelector = h('select', null, Object.keys(fixtures).map(value =>
  h('option', {value, selected: value === initialFixtureName ? 'selected' : ''}, value)
));
const expected = h('img', {className: 'expected', crossOrigin: 'Anonymous'});
const diff = h('canvas', {className: 'diff'});
const canvas = h('canvas', {className: 'actual'});
const fixtureDataLabel = h('summary');
const fixtureDataPre = h('pre');
const badCount = h('span', null, '0');

const prodMaterial = window.env === 'development' ? [] : [
  h('h1', {}, 'regl-gpu-lines render tests'),
  h('a', {href: 'https://github.com/rreusser/regl-gpu-lines'}, '← Back to project page'),
  h('p', {}, [
    'This page uses ',
    h('a', {href: 'https://unpkg.com/regl-gpu-lines@latest'}, 'regl-gpu-lines@latest'),
    ' from ',
    h('a', {href: 'https://unpkg.com'}, 'unpkg.com'),
    ' to run tests live.'
  ]),
];

document.body.appendChild(h('div', {}, [
  h('div', null, prodMaterial),
  h('div', {className: 'group'}, [fixtureSelector]),
  h('div', {className: 'group'}, [h('div', {}, 'Actual:'), canvas]),
  h('div', {className: 'group'}, [h('div', {}, 'Expected:'), expected]),
  h('div', {className: 'group'}, [h('div', {}, ['Diff (', badCount, ' incorrect pixels):']), diff]),
  h('details', {}, [fixtureDataLabel, h('code', {}, fixtureDataPre)])
]));

const regl = createREGL({
  canvas,
  pixelRatio: 1,
  attributes: {antialias: false, preserveDrawingBuffer: true},
  extensions: ['ANGLE_instanced_arrays'],
  optionalExtensions: ['OES_standard_derivatives']
});

fixtureSelector.addEventListener('input', e => executeFixture(e.target.value));

function flipPixels (data, width) {
  let tmp = new Uint8Array(width * 4);
  const height = data.length / (width * 4);
  for (let i = 0; i < height / 2; i++) {
    const idx1 = 4 * i * width;
    const idx2 = 4 * (height - i - 1) * width;
    const row1 = data.subarray(idx1, idx1 + width * 4);
    const row2 = data.subarray(idx2, idx2 + width * 4);
    tmp.set(row1);
    row1.set(row2);
    row2.set(tmp);
  }
  return data;
}

const expCanvas = h('canvas');
function compareImages(fixture, width, height) {
  const actualPixels = flipPixels(regl.read(), width);

  expCanvas.width = width;
  expCanvas.height = height;
  const expCtx = expCanvas.getContext('2d');
  expCtx.drawImage(expected, 0, 0);
  const expectedPixels = expCtx.getImageData(0, 0, width, height).data;

  diff.width = width;
  diff.height = height;
  const diffCtx = diff.getContext('2d');
  const diffImgData = diffCtx.getImageData(0, 0, width, height);

  const match = pixelmatch(actualPixels, expectedPixels, diffImgData.data, width, height);
  diffCtx.putImageData(diffImgData, 0, 0);

  badCount.textContent = match;
}

function getFixture (name) {
  if (window.env === 'development') {
    console.info(`Fetching local fixture: ${name}`);
    return fetch(`/test/fixtures/${name}/fixture.json`)
      .then(response => {
        if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        return response.text();
      });
  } else {
    console.info(`Using fixture: ${name}`);
    return Promise.resolve(fixtures[name].fixture);
  }
}

function executeFixture (name) {
  getFixture(name).then(fixtureText => {
    if (!fixtureText) throw new Error(`Invalid or missing test name "${name}"`);
    const fixture = JSON.parse(fixtureText);
    window.location.hash = name;

    const {width, height} = fixture;
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    renderFixture(regl, reglLines, fixture);

    fixtureDataLabel.textContent = `${name}/fixture.json`;
    fixtureDataPre.textContent = fixtureText;

    expected.onload = null;
    expected.src = '';
    expected.onload = () => compareImages(fixture, width, height);
    if (window.env === 'development') {
      expected.src = `/test/fixtures/${name}/expected.png`;
    } else {
      expected.src = `https://raw.githubusercontent.com/rreusser/regl-gpu-lines/main/test/fixtures/${name}/expected.png`;
    }
  });
}

executeFixture(initialFixtureName);

},{"../test/util/render-fixture.js":3,"pixelmatch":1}],3:[function(require,module,exports){
module.exports = renderFixture;

function replaceNullWithNaN (data) {
  for (let i = 0; i < data.length; i++) {
    if (Array.isArray(data[i])) {
      replaceNullWithNaN(data[i]);
    } else if (data[i] === null) {
      data[i] = NaN;
    }
  }
  return data;
}

function renderFixture(regl, createDrawLines, fixture) {
  const drawLines = createDrawLines(regl, {
    ...fixture.command,
    vert: fixture.command.vert.join('\n'),
    frag: fixture.command.frag.join('\n')
  });
  regl.poll();
  regl.clear({color: [1, 1, 1, 1], depth: 1});

  const lineData = fixture.data ? {...fixture.data} : {};
  lineData.vertexAttributes = {};
  lineData.endpointAttributes = {};


  if (fixture.vertexAttributes) {
    lineData.vertexAttributes = {};
    for (const [name, attribute] of Object.entries(fixture.vertexAttributes)) {
      const sanitizedAttr = replaceNullWithNaN(attribute);

      lineData.vertexAttributes[name] = regl.buffer(sanitizedAttr);
      lineData.vertexCount = sanitizedAttr.length;
    }
  }

  if (fixture.endpointAttributes) {
    lineData.endpointAttributes = {};
    for (const [name, attribute] of Object.entries(fixture.endpointAttributes)) {
      const sanitizedAttr = replaceNullWithNaN(attribute);

      // If endpoint data is provided, use it
      lineData.endpointAttributes[name] = regl.buffer(sanitizedAttr);
      lineData.endpointCount = sanitizedAttr.length;
    }
  }

  drawLines(lineData);
}

},{}]},{},[2]);
</script>
</body></html>